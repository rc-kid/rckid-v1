#pragma once

#include "avr.h"

/** PCD8544 aka the nokia 5110 display. 
 
    RST connection is not absolutely necessary. When not used it should be held high. 
 */

template<uint8_t RST, uint8_t SCE, uint8_t DC>
class PCD8544 {
public:
    PCD8544() {
        output<RST>();
        output<SCE>();
        output<DC>();
        high<RST>();
        high<SCE>();
        high<DC>();
	}
	
	void reset() {
        low<RST>();
        delay(10);
        high<RST>();
	}
	
	void enable() {
        reset();
        begin();
		writeCommand(0x21); // extended commands, power on
		writeCommand(0xbf); // VOP (contrast)
		writeCommand(0x04); // temp coef 
		writeCommand(0x14); // bias mode 1:48
		writeCommand(0x20); // basic commands, power on
		normalMode();
        gotoXY(0,0);
		clear();
        end();
	}
	
	void disable() {
        begin();
		writeCommand(0b00100100);
        end();
	}
	
	void normalMode() {
        begin();
		writeCommand(0x0c); // normal mode
        end();
	}
	
	void inverseMode() {
        begin();
		writeCommand(0x0d); // inverse mode
        end();
	}
	
	void clear() {
        begin();
	    for (int i = 0; i < 84 * 48 / 8; ++i)
		    writeData(0);	
        end();
	}
	
	void gotoXY(uint8_t col, uint8_t row) {
        begin();
	    writeCommand(0x80 | col);
		writeCommand(0x40 | row);	
        end();
	}
	
    /** Displays a single character.
     */
	void write(char x) {
        begin();
        writeChar(x);
        end();
	}
	
    /** Writes a null-terminated string. 
     */
	void write(char const * x) {
        begin();
	    while (*x != 0) {
            writeChar(*x);
            ++x;
        }
        end();
	}

    /** Writes a null-terminated string to a given position. 
     */
    void write(uint8_t col, uint8_t row, char const * x) {
        begin();
	    writeCommand(0x80 | col);
		writeCommand(0x40 | row);	
        while (*x != 0) {
            writeChar(*x);
            ++x;
        }
        end();
    }

    /** Writes a null-terminated string to a given position, using scaled font (2x larger) to a given position. 
     
        The large text uses the same font, but doubles each pixel, i.e. a cell size will become 10x16.
     */
    void writeLarge(uint8_t col, uint8_t row, char const * x) {
        begin();
	    writeCommand(0x80 | col);
		writeCommand(0x40 | row);	
        char const * xx = x;
        while (*xx != 0) {
            uint8_t * d = Font_ + (*xx - 0x20) * 5;
            for (uint8_t i = 0; i < 5; ++i) {
                uint8_t v = expandNibble(d[i]);
                writeData(v);
                writeData(v);
            }
            writeData(0);
            writeData(0);
            ++xx;
        }
	    writeCommand(0x80 | col);
		writeCommand(0x40 | row + 1);
        while (*x != 0) {
            uint8_t * d = Font_ + (*x - 0x20) * 5;
            for (uint8_t i = 0; i < 5; ++i) {
                uint8_t v = expandNibble(d[i] >> 4);
                writeData(v);
                writeData(v);
            }
            writeData(0);
            writeData(0);
            ++x;
        }
        end();
    }
	
    /** Writes an unsigned 16bit integer. 
     
        If the fill character is '\0' (default), the number will be left-justified, if ' ' it will be right justified, '0' will print all leading zeros as well. 
     */
	void write(uint16_t x, char fill = '\0') {
        begin();
        for (uint16_t i = 10000; i > 0; i = i / 10) {
            if (x > i || i == 1) {
                writeChar((x / i) + '0');
                fill = '0';
                x = x % i;
            } else if (fill != '\0') {
                writeChar(fill);
            }
        }
        end();
	}

    /** Displays a horizontal bar. 
     */
    void horizontalBar(uint8_t col, uint8_t row, uint8_t size, uint8_t value) {

    }
	
private:

    void begin() {
        spi::begin();
        low<SCE>();
    }

    void end() {
        high<SCE>();
        spi::end();
    }

    void writeCommand(uint8_t cmd) {
        low<DC>();
        spi::transfer(cmd);
        high<DC>();
	}
	
	void writeData(uint8_t data) {
        spi::transfer(data);
	}

    void writeData(uint8_t * data, uint16_t size) {
        spi::transfer(data, size);
    }

    void writeChar(char c) {
        writeData(Font_ + (c - 0x20) * 5, 5);
        //writeData(0);
    }

    static constexpr inline uint8_t Font_[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, // 20 space
	    0x00, 0x00, 0x5f, 0x00, 0x00, // 21!
	    0x00, 0x07, 0x00, 0x07, 0x00, // 22 "
		0x14, 0x7f, 0x14, 0x7f, 0x14, // 23 #
		0x24, 0x2a, 0x7f, 0x2a, 0x12, // 24 $
		0x23, 0x13, 0x08, 0x64, 0x62, // 25 %
		0x36, 0x49, 0x55, 0x22, 0x50, // 26 &
		0x00, 0x05, 0x03, 0x00, 0x00, // 27 '
		0x00, 0x1c, 0x22, 0x41, 0x00, // 28 (
		0x00, 0x41, 0x22, 0x1c, 0x00, // 29 )
		0x14, 0x08, 0x3e, 0x08, 0x14, // 2a *
		0x08, 0x08, 0x3e, 0x08, 0x08, // 2b +
		0x00, 0x50, 0x30, 0x00, 0x00, // 2c ,
		0x08, 0x08, 0x08, 0x08, 0x08, // 2d -
		0x00, 0x60, 0x60, 0x00, 0x00, // 2e .
		0x20, 0x10, 0x08, 0x04, 0x02, // 2f /
		0x3e, 0x51, 0x49, 0x45, 0x3e, // 30 0
		0x00, 0x42, 0x7f, 0x40, 0x00, // 31 1
		0x42, 0x61, 0x51, 0x49, 0x46, // 32 2
		0x21, 0x41, 0x45, 0x4b, 0x31, // 33 3
		0x18, 0x14, 0x12, 0x7f, 0x10, // 34 4
		0x27, 0x45, 0x45, 0x45, 0x39, // 35 5
		0x3c, 0x4a, 0x49, 0x49, 0x30, // 36 6
		0x01, 0x71, 0x09, 0x05, 0x03, // 37 7
		0x36, 0x49, 0x49, 0x49, 0x36, // 38 8
		0x06, 0x49, 0x49, 0x29, 0x1e, // 39 9
		0x00, 0x36, 0x36, 0x00, 0x00, // 3a :
		0x00, 0x56, 0x36, 0x00, 0x00, // 3b ;
		0x08, 0x14, 0x22, 0x41, 0x00, // 3c <
		0x14, 0x14, 0x14, 0x14, 0x14, // 3d =
		0x00, 0x41, 0x22, 0x14, 0x08, // 3e >
		0x02, 0x01, 0x51, 0x09, 0x06, // 3f ?
		0x32, 0x49, 0x79, 0x41, 0x3e, // 40 @
		0x7e, 0x11, 0x11, 0x11, 0x7e, // 41 A
		0x7f, 0x49, 0x49, 0x49, 0x36, // 42 B
		0x3e, 0x41, 0x41, 0x41, 0x22, // 43 C
		0x7f, 0x41, 0x41, 0x22, 0x1c, // 44 D
		0x7f, 0x49, 0x49, 0x49, 0x41, // 45 E
		0x7f, 0x09, 0x09, 0x09, 0x01, // 46 F
		0x3e, 0x41, 0x49, 0x49, 0x7a, // 47 G
		0x7f, 0x08, 0x08, 0x08, 0x7f, // 48 H
		0x00, 0x41, 0x7f, 0x41, 0x00, // 49 I
		0x20, 0x40, 0x41, 0x3f, 0x01, // 4a J
		0x7f, 0x08, 0x14, 0x22, 0x41, // 4b K
		0x7f, 0x40, 0x40, 0x40, 0x40, // 4c L
		0x7f, 0x02, 0x0c, 0x02, 0x7f, // 4d M
		0x7f, 0x04, 0x08, 0x10, 0x7f, // 4e N
		0x3e, 0x41, 0x41, 0x41, 0x3e, // 4f O
		0x7f, 0x09, 0x09, 0x09, 0x06, // 50 P
		0x3e, 0x41, 0x51, 0x21, 0x5e, // 51 Q
		0x7f, 0x09, 0x19, 0x29, 0x46, // 52 R
		0x46, 0x49, 0x49, 0x49, 0x31, // 53 S
		0x01, 0x01, 0x7f, 0x01, 0x01, // 54 T
		0x3f, 0x40, 0x40, 0x40, 0x3f, // 55 U
		0x1f, 0x20, 0x40, 0x20, 0x1f, // 56 V
		0x3f, 0x40, 0x38, 0x40, 0x3f, // 57 W
		0x63, 0x14, 0x08, 0x14, 0x63, // 58 X
		0x07, 0x08, 0x70, 0x08, 0x07, // 59 Y
		0x61, 0x51, 0x49, 0x45, 0x43, // 5a Z
		0x00, 0x7f, 0x41, 0x41, 0x00, // 5b [
		0x02, 0x04, 0x08, 0x10, 0x20, // 5c ï¿½
		0x00, 0x41, 0x41, 0x7f, 0x00, // 5d ]
		0x04, 0x02, 0x01, 0x02, 0x04, // 5e ^
		0x40, 0x40, 0x40, 0x40, 0x40, // 5f _
		0x00, 0x01, 0x02, 0x04, 0x00, // 60 `
		0x20, 0x54, 0x54, 0x54, 0x78, // 61 a
		0x7f, 0x48, 0x44, 0x44, 0x38, // 62 b
		0x38, 0x44, 0x44, 0x44, 0x20, // 63 c
		0x38, 0x44, 0x44, 0x48, 0x7f, // 64 d
		0x38, 0x54, 0x54, 0x54, 0x18, // 65 e
		0x08, 0x7e, 0x09, 0x01, 0x02, // 66 f
		0x0c, 0x52, 0x52, 0x52, 0x3e, // 67 g
		0x7f, 0x08, 0x04, 0x04, 0x78, // 68 h
		0x00, 0x44, 0x7d, 0x40, 0x00, // 69 i
		0x20, 0x40, 0x44, 0x3d, 0x00, // 6a j 
		0x7f, 0x10, 0x28, 0x44, 0x00, // 6b k
		0x00, 0x41, 0x7f, 0x40, 0x00, // 6c l
		0x7c, 0x04, 0x18, 0x04, 0x78, // 6d m
		0x7c, 0x08, 0x04, 0x04, 0x78, // 6e n
		0x38, 0x44, 0x44, 0x44, 0x38, // 6f o
		0x7c, 0x14, 0x14, 0x14, 0x08, // 70 p
		0x08, 0x14, 0x14, 0x18, 0x7c, // 71 q
		0x7c, 0x08, 0x04, 0x04, 0x08, // 72 r
		0x48, 0x54, 0x54, 0x54, 0x20, // 73 s
		0x04, 0x3f, 0x44, 0x40, 0x20, // 74 t
		0x3c, 0x40, 0x40, 0x20, 0x7c, // 75 u
		0x1c, 0x20, 0x40, 0x20, 0x1c, // 76 v
		0x3c, 0x40, 0x30, 0x40, 0x3c, // 77 w
		0x44, 0x28, 0x10, 0x28, 0x44, // 78 x
		0x0c, 0x50, 0x50, 0x50, 0x3c, // 79 y
		0x44, 0x64, 0x54, 0x4c, 0x44, // 7a z
		0x00, 0x08, 0x36, 0x41, 0x00, // 7b {
		0x00, 0x00, 0x7f, 0x00, 0x00, // 7c |
		0x00, 0x41, 0x36, 0x08, 0x00, // 7d );
		0x10, 0x08, 0x08, 0x10, 0x08, // 7e ?
		0x00, 0x06, 0x09, 0x09, 0x06, // 7f ?
    };

} ;


